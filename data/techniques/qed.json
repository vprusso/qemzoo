{
  "description": [
    "Quantum Error Detection (QED) encodes logical qubits into a quantum error-detecting code and uses stabilizer measurements to flag when errors have occurred. Unlike full quantum error correction (QEC), QED does not attempt to identify and reverse errors \u2014 it simply discards flagged runs via post-selection, keeping only runs where no error was detected.",
    "The simplest example is the \\([\\![ 4, 2, 2 ]\\!]\\) code, which encodes 2 logical qubits into 4 physical qubits and can detect any single-qubit error. More generally, any \\([\\![ n, k, d ]\\!]\\) stabilizer code with distance \\(d \\geq 2\\) can detect up to \\(d-1\\) errors.",
    "QED is particularly attractive for near-term devices because it requires fewer qubits and simpler circuits than full QEC, while still providing exponential suppression of detectable errors (at the cost of a reduced acceptance rate).",
    "QED has been demonstrated across multiple hardware platforms: superconducting qubits (Bell state preparation with the \\([\\![ 2, 0, 2 ]\\!]\\) code, the \\([\\![ 4, 2, 2 ]\\!]\\) code for chemistry and state preparation, and GHZ states on 120+ qubits), trapped-ion systems (Iceberg codes for quantum volume on Quantinuum H2, dissipative quantum dynamics), and silicon quantum computers (2026)."
  ],
  "how_it_works": [
    "Encode \\(k\\) logical qubits into \\(n\\) physical qubits using an error-detecting code (e.g., the \\([\\![ 4, 2, 2 ]\\!]\\) code).",
    "Perform the desired quantum computation using fault-tolerant (or native) gate implementations on the encoded qubits.",
    "Measure the code's stabilizer generators (either at the end or at intermediate points in the circuit).",
    "Post-select: keep only the measurement outcomes where all stabilizers return the +1 eigenvalue (no error detected). Discard flagged runs.",
    "Decode the surviving logical measurement outcomes to obtain the result."
  ],
  "key_equations": [
    {
      "label": "Post-selected fidelity (p_detectable = prob. of detected errors, p_undetectable = prob. of undetected errors)",
      "latex": "F_{\\text{post}} = \\frac{F_{\\text{raw}} - p_{\\text{undetectable}}}{1 - p_{\\text{detectable}}} \\geq F_{\\text{raw}}"
    },
    {
      "label": "Acceptance rate (p = physical error rate, n = number of qubits, d_circuit = circuit depth)",
      "latex": "P_{\\text{accept}} = 1 - p_{\\text{detectable}} \\approx (1 - p)^{n \\cdot d_{\\text{circuit}}}"
    },
    {
      "label": "Undetectable error scaling",
      "latex": "p_{\\text{undetectable}} = O(p^d) \\text{ for a distance-}d\\text{ code}"
    }
  ],
  "advantages": [
    "Exponential suppression of detectable errors with code distance",
    "No noise model required \u2014 code structure determines detection capability",
    "Simpler than full quantum error correction (fewer qubits, simpler syndrome extraction)",
    "Can be combined with other QEM techniques on the post-selected data"
  ],
  "disadvantages": [
    "Acceptance rate decreases with noise rate and circuit depth",
    "Undetectable errors (weight \\(\\geq d\\)) pass through uncorrected",
    "Requires additional physical qubits for encoding (overhead ratio \\(n/k\\))",
    "Fault-tolerant gate compilation adds circuit depth"
  ],
  "use_cases": [
    "Near-term experiments where full QEC is not yet feasible",
    "Improving fidelity of small quantum computations (2-4 logical qubits)",
    "Hybrid QEM pipelines: QED post-selection followed by ZNE or PEC on surviving data",
    "Lattice gauge theory simulations where gauge symmetry provides a natural detecting code"
  ]
}