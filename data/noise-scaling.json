[
  {
    "id": "unitary-folding",
    "name": "Unitary Folding",
    "aliases": ["gate folding", "circuit folding"],
    "summary": "Amplifies noise by inserting identity-equivalent gate pairs \\(G G^\\dagger\\) into the circuit. For a scale factor \\(\\lambda\\), gates are replaced with \\(G (G^\\dagger G)^{(\\lambda-1)/2}\\). Can be applied globally (to the whole circuit) or locally (to individual gates). Simple to implement but requires integer or odd-integer scale factors for exact folding.",
    "properties": {
      "Scale factors": "Integer or odd-integer multiples (1, 3, 5, ...); fractional via partial folding",
      "Hardware requirements": "None beyond standard gate set",
      "Advantages": "Simple, no pulse-level access needed, widely supported",
      "Disadvantages": "Large stretch factors needed for deep circuits; folded gates may have different noise than original"
    },
    "references": ["giurgica2020", "he2020"]
  },
  {
    "id": "pulse-stretching",
    "name": "Pulse Stretching",
    "aliases": ["time stretching", "pulse scaling"],
    "summary": "Amplifies noise by stretching the duration of control pulses while maintaining their area (so the unitary is unchanged). Assumes that noise scales linearly with gate duration, which holds for some but not all noise sources. Requires pulse-level control of the quantum hardware.",
    "properties": {
      "Scale factors": "Continuous (any \\(\\lambda \\geq 1\\))",
      "Hardware requirements": "Pulse-level access (e.g., OpenPulse on IBM systems)",
      "Advantages": "Continuous scale factors; no additional gates",
      "Disadvantages": "Assumes noise ∝ duration (often inaccurate); requires pulse calibration; not available on all platforms"
    },
    "references": ["temme2017", "kandala2019"]
  },
  {
    "id": "identity-insertion",
    "name": "Identity Insertion",
    "aliases": ["identity scaling"],
    "summary": "Amplifies noise by inserting identity operations between circuit gates, extending circuit duration and exposing qubits to more decoherence. Unlike folding (\\(G \\to GG^\\dagger G\\)), identity insertion focuses on passive decoherence rather than gate noise, making it effective when T1/T2 errors dominate.",
    "properties": {
      "Scale factors": "Discrete (ratio of scaled to original depth)",
      "Hardware requirements": "None",
      "Advantages": "Simple; effective for decoherence-dominated noise",
      "Disadvantages": "Primarily scales idle noise, not gate noise; coarse control"
    },
    "references": ["giurgica2020"]
  },
  {
    "id": "circuit-unoptimization",
    "name": "Circuit Unoptimization",
    "aliases": ["quantum circuit unoptimization"],
    "summary": "Amplifies noise by iteratively transforming a circuit into an equivalent but longer circuit via a four-step procedure: (1) insert a random two-qubit gate \\(A\\) and \\(A^\\dagger\\) between existing gates, (2) swap gates via conjugation, (3) decompose into elementary gates, (4) resynthesize. The noise scale factor is \\(\\lambda = n(R(C))/n(C)\\) where \\(n\\) is gate count. Unlike folding, unoptimization produces structurally different circuits, enabling averaging over exponentially many variants to reduce coherent error bias. Resists server-side compiler optimization.",
    "properties": {
      "Scale factors": "Continuous (including fractional values near 1.0)",
      "Hardware requirements": "None",
      "Advantages": "Exponentially many circuit variants for averaging; resists compiler simplification; fractional scaling",
      "Disadvantages": "More complex to implement; circuit structure changes significantly"
    },
    "references": ["mori2024", "pelofske2025"]
  },
  {
    "id": "pea-amplification",
    "name": "Probabilistic Error Amplification",
    "aliases": ["learned noise injection", "PEA"],
    "summary": "Amplifies noise by learning the per-layer noise model (via sparse Pauli–Lindblad tomography) and probabilistically injecting additional Pauli errors proportional to the learned rates. Provides accurate, targeted amplification without the assumptions of pulse stretching or the discrete steps of folding.",
    "properties": {
      "Scale factors": "Continuous",
      "Hardware requirements": "Noise characterization (Pauli–Lindblad learning)",
      "Advantages": "Accurate amplification using learned noise model; no pulse access needed",
      "Disadvantages": "Requires upfront noise learning; noise model may drift"
    },
    "references": ["kim2023", "vandenberg2023"]
  }
]
